<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game</title>
    <style>
        :root {
            --dark-square: #769656;
            --light-square: #eeeed2;
            --highlight: rgba(255, 255, 0, 0.4);
            --possible-move: rgba(0, 0, 0, 0.2);
            --check-highlight: rgba(255, 0, 0, 0.5);
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #2e2e2e;
            color: #fff;
        }
        
        .header {
            margin-bottom: 20px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 0;
        }
        
        .header p {
            font-size: 1.2rem;
            margin-top: 5px;
            color: #ccc;
        }
        
        .game-container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            background-color: #3c3c3c;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);
        }
        
        .board-container {
            position: relative;
            flex-shrink: 0;
        }
        
        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 560px;
            height: 560px;
            border: 8px solid #272522;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }
        
        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .light {
            background-color: var(--light-square);
        }
        
        .dark {
            background-color: var(--dark-square);
        }
        
        .piece {
            width: 80%;
            height: 80%;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 1;
        }
        
        .highlighted {
            background-color: var(--highlight);
        }
        
        .check {
            background-color: var(--check-highlight);
        }
        
        .possible-move::after {
            content: '';
            position: absolute;
            width: 25%;
            height: 25%;
            border-radius: 50%;
            background-color: var(--possible-move);
        }
        
        .coordinates {
            position: absolute;
            font-size: 12px;
            color: #ccc;
            user-select: none;
        }
        
        .rank {
            left: -20px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .file {
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        
        .game-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #272522;
            padding: 15px;
            border-radius: 8px;
            width: 300px;
        }
        
        .turn-indicator {
            font-size: 1.2rem;
            margin-bottom: 10px;
        }
        
        .game-status {
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: #ffcc00;
            font-weight: bold;
            min-height: 1.1rem;
        }
        
        .move-history {
            width: 100%;
            max-height: 350px;
            overflow-y: auto;
            background-color: #222;
            border-radius: 5px;
            padding: 10px;
            box-sizing: border-box;
            margin-bottom: 10px;
        }
        
        .notation-table {
            width: 100%;
            border-collapse: collapse;
            font-family: monospace;
            color: #eee;
        }
        
        .notation-table th {
            text-align: left;
            padding: 5px;
            font-weight: bold;
            border-bottom: 1px solid #444;
        }
        
        .notation-table td {
            padding: 5px 10px;
            white-space: nowrap;
        }
        
        .notation-table tr:hover {
            background-color: #333;
            cursor: pointer;
        }
        
        .notation-table td.active {
            background-color: #303030;
            font-weight: bold;
            color: white;
        }
        
        .captured-pieces {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: 10px;
        }
        
        .captured-white, .captured-black {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            padding: 5px;
            border-radius: 4px;
            background-color: #333;
            min-height: 30px;
            width: 48%;
        }
        
        .captured-piece {
            width: 20px;
            height: 20px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        
        button {
            background-color: #4d4d4d;
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #666;
        }
        
        button:active {
            background-color: #555;
        }
        
        button:disabled {
            background-color: #333;
            color: #777;
            cursor: not-allowed;
        }
        
        .move-navigation {
            display: flex;
            justify-content: center;
            gap: 5px;
            margin: 10px 0;
        }
        
        .move-navigation button {
            min-width: 40px;
            font-weight: bold;
        }
        
        .game-buttons {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        
        /* Promotion dialog */
        .promotion-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        
        .promotion-container {
            background-color: #3c3c3c;
            padding: 20px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }
        
        .promotion-container h2 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #fff;
        }
        
        .promotion-pieces {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .promotion-piece {
            width: 60px;
            height: 60px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            cursor: pointer;
            background-color: var(--light-square);
            border-radius: 4px;
            transition: transform 0.2s;
        }
        
        .promotion-piece:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.5);
        }
        
        @media (max-width: 1000px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            
            .game-info {
                width: 100%;
                max-width: 560px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Chess Game</h1>
        <p>Play chess against yourself or a friend</p>
    </div>
    
    <div class="game-container">
        <div class="board-container">
            <div class="chessboard" id="chessboard"></div>
        </div>
        
        <div class="game-info">
            <div class="turn-indicator" id="turn-indicator">Current Turn: White</div>
            <div class="game-status" id="game-status"></div>
            
            <div class="captured-pieces">
                <div class="captured-white" id="captured-white"></div>
                <div class="captured-black" id="captured-black"></div>
            </div>
            
            <div class="move-history" id="move-history">
                <table class="notation-table">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>White</th>
                            <th>Black</th>
                        </tr>
                    </thead>
                    <tbody id="notation-body">
                        <!-- Move notation will be added here -->
                    </tbody>
                </table>
            </div>
            
            <div class="move-navigation">
                <button id="first-move">|&lt;</button>
                <button id="prev-move">&lt;</button>
                <button id="next-move">&gt;</button>
                <button id="last-move">&gt;|</button>
            </div>
            
            <div class="game-buttons">
                <button id="new-game">New Game</button>
                <button id="flip-board">Flip Board</button>
                <button id="save-pgn">Save PGN</button>
                <button id="load-pgn-btn">Load PGN</button>
                <input type="file" id="pgn-file-input" accept=".pgn,text/plain" style="display: none;">
            </div>
        </div>
    </div>
    
    <!-- Pawn Promotion Dialog -->
    <div class="promotion-modal" id="promotion-modal">
        <div class="promotion-container">
            <h2>Choose a piece for pawn promotion</h2>
            <div class="promotion-pieces" id="promotion-pieces">
                <!-- Promotion pieces will be added here -->
            </div>
        </div>
    </div>

    <script>
        // Chess game logic
        class ChessGame {
            constructor() {
                this.board = this.createInitialBoard();
                this.currentPlayer = 'white';
                this.selectedPiece = null;
                this.possibleMoves = [];
                this.moveHistory = [];
                this.capturedPieces = { white: [], black: [] };
                this.boardOrientation = 'white'; // white at bottom
                this.currentMoveIndex = 0; // for move navigation
                this.boardStates = [this.deepCopyBoard(this.board)]; // store board states for navigation
                this.kingPositions = { white: [7, 4], black: [0, 4] }; // Store king positions for check detection
                this.isInCheck = { white: false, black: false };
                this.gameOver = false;
                this.gameStatus = '';
                
                // Special move flags
                this.castlingRights = {
                    white: { kingSide: true, queenSide: true },
                    black: { kingSide: true, queenSide: true }
                };
                
                this.enPassantTarget = null; // Square that can be captured via en passant
                
                // For pawn promotion
                this.promotionPending = false;
                this.promotionMove = null;
                
                this.setupBoard();
                this.setupEventListeners();
            }
            
            deepCopyBoard(board) {
                return board.map(row => [...row]);
            }
            
            createInitialBoard() {
                return [
                    ['rook-black', 'knight-black', 'bishop-black', 'queen-black', 'king-black', 'bishop-black', 'knight-black', 'rook-black'],
                    ['pawn-black', 'pawn-black', 'pawn-black', 'pawn-black', 'pawn-black', 'pawn-black', 'pawn-black', 'pawn-black'],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    ['pawn-white', 'pawn-white', 'pawn-white', 'pawn-white', 'pawn-white', 'pawn-white', 'pawn-white', 'pawn-white'],
                    ['rook-white', 'knight-white', 'bishop-white', 'queen-white', 'king-white', 'bishop-white', 'knight-white', 'rook-white']
                ];
            }
            
            setupBoard() {
                const chessboard = document.getElementById('chessboard');
                chessboard.innerHTML = '';
                
                const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
                const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];
                
                // Mapping function to convert our piece names to standard notation
                const getPieceImage = (piece) => {
                    if (!piece) return null;
                    
                    const pieceMap = {
                        'pawn-white': 'wP', 'rook-white': 'wR', 'knight-white': 'wN', 
                        'bishop-white': 'wB', 'queen-white': 'wQ', 'king-white': 'wK',
                        'pawn-black': 'bP', 'rook-black': 'bR', 'knight-black': 'bN', 
                        'bishop-black': 'bB', 'queen-black': 'bQ', 'king-black': 'bK'
                    };
                    
                    return pieceMap[piece];
                };
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.classList.add('square');
                        
                        // Determine actual board position based on orientation
                        let actualRow = this.boardOrientation === 'white' ? row : 7 - row;
                        let actualCol = this.boardOrientation === 'white' ? col : 7 - col;
                        
                        // Set square color
                        if ((row + col) % 2 === 0) {
                            square.classList.add('light');
                        } else {
                            square.classList.add('dark');
                        }
                        
                        // Set data attributes for position
                        square.dataset.row = actualRow;
                        square.dataset.col = actualCol;
                        
                        // Add coordinates
                        if (col === 0) {
                            const rankCoord = document.createElement('div');
                            rankCoord.classList.add('coordinates', 'rank');
                            rankCoord.textContent = ranks[actualRow];
                            square.appendChild(rankCoord);
                        }
                        
                        if (row === 7) {
                            const fileCoord = document.createElement('div');
                            fileCoord.classList.add('coordinates', 'file');
                            fileCoord.textContent = files[actualCol];
                            square.appendChild(fileCoord);
                        }
                        
                        // Add piece if present
                        const piece = this.board[actualRow][actualCol];
                        if (piece) {
                            const pieceElement = document.createElement('div');
                            pieceElement.classList.add('piece');
                            const pieceFileName = getPieceImage(piece);
                            pieceElement.style.backgroundImage = `url('img/${pieceFileName}.png')`;
                            square.appendChild(pieceElement);
                            
                            // Highlight king if in check
                            if (piece === 'king-white' && this.isInCheck.white) {
                                square.classList.add('check');
                            }
                            if (piece === 'king-black' && this.isInCheck.black) {
                                square.classList.add('check');
                            }
                        }
                        
                        chessboard.appendChild(square);
                    }
                }
                
                this.updateTurnIndicator();
                this.updateCapturedPieces();
                this.updateGameStatus();
            }
            
            setupEventListeners() {
                const chessboard = document.getElementById('chessboard');
                chessboard.addEventListener('click', (e) => {
                    if (this.gameOver || this.promotionPending) return;
                    
                    const square = e.target.closest('.square');
                    if (!square) return;
                    
                    const row = parseInt(square.dataset.row);
                    const col = parseInt(square.dataset.col);
                    this.handleSquareClick(row, col);
                });
                
                document.getElementById('new-game').addEventListener('click', () => {
                    this.resetGame();
                });
                
                document.getElementById('flip-board').addEventListener('click', () => {
                    this.flipBoard();
                });
                
                document.getElementById('first-move').addEventListener('click', () => {
                    this.goToMove(0);
                });
                
                document.getElementById('prev-move').addEventListener('click', () => {
                    this.goToMove(Math.max(0, this.currentMoveIndex - 1));
                });
                
                document.getElementById('next-move').addEventListener('click', () => {
                    this.goToMove(Math.min(this.moveHistory.length, this.currentMoveIndex + 1));
                });
                
                document.getElementById('last-move').addEventListener('click', () => {
                    this.goToMove(this.moveHistory.length);
                });
                
                // Add click event for notation rows
                document.getElementById('notation-body').addEventListener('click', (e) => {
                    const row = e.target.closest('tr');
                    if (!row || !row.dataset.moveIndex) return;
                    
                    const moveIndex = parseInt(row.dataset.moveIndex);
                    this.goToMove(moveIndex);
                });
                
                // Setup promotion modal event listeners
                document.getElementById('promotion-pieces').addEventListener('click', (e) => {
                    const piece = e.target.closest('.promotion-piece');
                    if (!piece || !piece.dataset.piece) return;
                    
                    this.completePromotion(piece.dataset.piece);
                });
                
                // PGN save and load
                document.getElementById('save-pgn').addEventListener('click', () => {
                    this.savePGN();
                });
                
                document.getElementById('load-pgn-btn').addEventListener('click', () => {
                    document.getElementById('pgn-file-input').click();
                });
                
                document.getElementById('pgn-file-input').addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        const file = e.target.files[0];
                        const reader = new FileReader();
                        
                        reader.onload = (event) => {
                            const pgnText = event.target.result;
                            this.loadPGN(pgnText);
                        };
                        
                        reader.readAsText(file);
                    }
                });
            }
            
            handleSquareClick(row, col) {
                // If a piece is already selected
                if (this.selectedPiece) {
                    const [selectedRow, selectedCol] = this.selectedPiece;
                    
                    // Check if the clicked square is in possible moves
                    const moveIndex = this.possibleMoves.findIndex(
                        move => move[0] === row && move[1] === col
                    );
                    
                    if (moveIndex !== -1) {
                        // Special case for pawn promotion
                        const piece = this.board[selectedRow][selectedCol];
                        const isPawn = piece && piece.startsWith('pawn');
                        const isPromotionRank = (piece.endsWith('white') && row === 0) || 
                                              (piece.endsWith('black') && row === 7);
                        
                        if (isPawn && isPromotionRank) {
                            this.promptPromotion(selectedRow, selectedCol, row, col);
                        } else {
                            // Check if we're in the middle of the move history
                            if (this.currentMoveIndex < this.moveHistory.length) {
                                // Truncate move history and boardStates at current position
                                this.truncateMoveHistory();
                            }
                            
                            // Make the move
                            this.makeMove(selectedRow, selectedCol, row, col);
                        }
                        this.clearSelection();
                    } else {
                        // If clicking on another piece of same color, select that piece instead
                        const clickedPiece = this.board[row][col];
                        if (clickedPiece && clickedPiece.endsWith(this.currentPlayer)) {
                            this.selectPiece(row, col);
                        } else {
                            // Otherwise clear selection
                            this.clearSelection();
                        }
                    }
                } else {
                    // If no piece is selected, try to select one
                    const piece = this.board[row][col];
                    if (piece && piece.endsWith(this.currentPlayer)) {
                        this.selectPiece(row, col);
                    }
                }
            }
            
            selectPiece(row, col) {
                this.selectedPiece = [row, col];
                this.possibleMoves = this.calculateLegalMoves(row, col);
                this.highlightSquares();
            }
            
            clearSelection() {
                this.selectedPiece = null;
                this.possibleMoves = [];
                this.clearHighlights();
            }
            
            highlightSquares() {
                this.clearHighlights();
                
                // Highlight selected piece
                if (this.selectedPiece) {
                    const [row, col] = this.selectedPiece;
                    const selectedSquare = document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
                    if (selectedSquare) {
                        selectedSquare.classList.add('highlighted');
                    }
                    
                    // Highlight possible moves
                    this.possibleMoves.forEach(([moveRow, moveCol]) => {
                        const moveSquare = document.querySelector(`.square[data-row="${moveRow}"][data-col="${moveCol}"]`);
                        if (moveSquare) {
                            moveSquare.classList.add('possible-move');
                        }
                    });
                }
                
                // Highlight kings in check
                for (const color of ['white', 'black']) {
                    if (this.isInCheck[color]) {
                        const [kingRow, kingCol] = this.kingPositions[color];
                        const kingSquare = document.querySelector(`.square[data-row="${kingRow}"][data-col="${kingCol}"]`);
                        if (kingSquare) {
                            kingSquare.classList.add('check');
                        }
                    }
                }
            }
            
            clearHighlights() {
                document.querySelectorAll('.square').forEach(square => {
                    square.classList.remove('highlighted', 'possible-move', 'check');
                });
            }
            
            calculatePossibleMoves(row, col) {
                const piece = this.board[row][col];
                if (!piece) return [];
                
                const [type, color] = piece.split('-');
                const moves = [];
                
                switch (type) {
                    case 'pawn':
                        this.calculatePawnMoves(row, col, color, moves);
                        break;
                    case 'rook':
                        this.calculateRookMoves(row, col, color, moves);
                        break;
                    case 'knight':
                        this.calculateKnightMoves(row, col, color, moves);
                        break;
                    case 'bishop':
                        this.calculateBishopMoves(row, col, color, moves);
                        break;
                    case 'queen':
                        this.calculateQueenMoves(row, col, color, moves);
                        break;
                    case 'king':
                        this.calculateKingMoves(row, col, color, moves);
                        break;
                }
                
                return moves;
            }
            
            // This filters moves that would leave the king in check
            calculateLegalMoves(row, col) {
                const piece = this.board[row][col];
                if (!piece) return [];
                
                const [, color] = piece.split('-');
                const possibleMoves = this.calculatePossibleMoves(row, col);
                const legalMoves = [];
                
                // Test each move to see if it leaves the king in check
                for (const [toRow, toCol] of possibleMoves) {
                    // Make a temporary move
                    const originalBoard = this.deepCopyBoard(this.board);
                    const capturedPiece = this.board[toRow][toCol];
                    
                    // Special case for en passant
                    let capturedEnPassantPiece = null;
                    let enPassantCapturePos = null;
                    
                    if (piece.startsWith('pawn') && col !== toCol && !capturedPiece) {
                        // This is an en passant capture
                        const enPassantRow = color === 'white' ? toRow + 1 : toRow - 1;
                        capturedEnPassantPiece = this.board[enPassantRow][toCol];
                        enPassantCapturePos = [enPassantRow, toCol];
                        this.board[enPassantRow][toCol] = null;
                    }
                    
                    // Move piece for testing
                    this.board[toRow][toCol] = piece;
                    this.board[row][col] = null;
                    
                    // Special case for castling - also move the rook
                    let rookOriginalPos = null;
                    let rookNewPos = null;
                    
                    if (piece.startsWith('king') && Math.abs(col - toCol) > 1) {
                        // This is castling
                        const rookCol = toCol === 6 ? 7 : 0; // Kingside or queenside
                        const newRookCol = toCol === 6 ? 5 : 3; // Where rook goes
                        
                        rookOriginalPos = [row, rookCol];
                        rookNewPos = [row, newRookCol];
                        
                        const rook = this.board[row][rookCol];
                        this.board[row][newRookCol] = rook;
                        this.board[row][rookCol] = null;
                    }
                    
                    // Update king position if moving king
                    let originalKingPos = null;
                    if (piece.startsWith('king')) {
                        originalKingPos = [...this.kingPositions[color]];
                        this.kingPositions[color] = [toRow, toCol];
                    }
                    
                    // Check if king is in check after the move
                    const inCheck = this.isKingInCheck(color);
                    
                    // Restore the board
                    this.board = this.deepCopyBoard(originalBoard);
                    
                    // Restore king position if it was moved
                    if (originalKingPos) {
                        this.kingPositions[color] = originalKingPos;
                    }
                    
                    // If the move doesn't leave king in check, it's legal
                    if (!inCheck) {
                        legalMoves.push([toRow, toCol]);
                    }
                }
                
                return legalMoves;
            }
            
            calculatePawnMoves(row, col, color, moves) {
                const direction = color === 'white' ? -1 : 1;
                const startingRow = color === 'white' ? 6 : 1;
                
                // Forward move
                if (this.isInBounds(row + direction, col) && !this.board[row + direction][col]) {
                    moves.push([row + direction, col]);
                    
                    // Double forward move from starting position
                    if (row === startingRow && !this.board[row + 2 * direction][col]) {
                        moves.push([row + 2 * direction, col]);
                    }
                }
                
                // Capture moves (including en passant)
                for (const colOffset of [-1, 1]) {
                    const newRow = row + direction;
                    const newCol = col + colOffset;
                    
                    if (this.isInBounds(newRow, newCol)) {
                        const targetPiece = this.board[newRow][newCol];
                        
                        // Normal capture
                        if (targetPiece && !targetPiece.endsWith(color)) {
                            moves.push([newRow, newCol]);
                        }
                        // En passant capture
                        else if (this.enPassantTarget && 
                                newRow === this.enPassantTarget[0] && 
                                newCol === this.enPassantTarget[1]) {
                            moves.push([newRow, newCol]);
                        }
                    }
                }
            }
            
            calculateRookMoves(row, col, color, moves) {
                const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]; // right, down, left, up
                
                for (const [rowDir, colDir] of directions) {
                    let currentRow = row + rowDir;
                    let currentCol = col + colDir;
                    
                    while (this.isInBounds(currentRow, currentCol)) {
                        const targetPiece = this.board[currentRow][currentCol];
                        if (!targetPiece) {
                            moves.push([currentRow, currentCol]);
                        } else {
                            if (!targetPiece.endsWith(color)) {
                                moves.push([currentRow, currentCol]);
                            }
                            break;
                        }
                        
                        currentRow += rowDir;
                        currentCol += colDir;
                    }
                }
            }
            
            calculateKnightMoves(row, col, color, moves) {
                const offsets = [
                    [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                    [1, -2], [1, 2], [2, -1], [2, 1]
                ];
                
                for (const [rowOffset, colOffset] of offsets) {
                    const newRow = row + rowOffset;
                    const newCol = col + colOffset;
                    
                    if (this.isInBounds(newRow, newCol)) {
                        const targetPiece = this.board[newRow][newCol];
                        if (!targetPiece || !targetPiece.endsWith(color)) {
                            moves.push([newRow, newCol]);
                        }
                    }
                }
            }
            
            calculateBishopMoves(row, col, color, moves) {
                const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]]; // down-right, down-left, up-right, up-left
                
                for (const [rowDir, colDir] of directions) {
                    let currentRow = row + rowDir;
                    let currentCol = col + colDir;
                    
                    while (this.isInBounds(currentRow, currentCol)) {
                        const targetPiece = this.board[currentRow][currentCol];
                        if (!targetPiece) {
                            moves.push([currentRow, currentCol]);
                        } else {
                            if (!targetPiece.endsWith(color)) {
                                moves.push([currentRow, currentCol]);
                            }
                            break;
                        }
                        
                        currentRow += rowDir;
                        currentCol += colDir;
                    }
                }
            }
            
            calculateQueenMoves(row, col, color, moves) {
                this.calculateRookMoves(row, col, color, moves);
                this.calculateBishopMoves(row, col, color, moves);
            }
            
            calculateKingMoves(row, col, color, moves) {
                const offsets = [
                    [-1, -1], [-1, 0], [-1, 1],
                    [0, -1], [0, 1],
                    [1, -1], [1, 0], [1, 1]
                ];
                
                // Normal king moves
                for (const [rowOffset, colOffset] of offsets) {
                    const newRow = row + rowOffset;
                    const newCol = col + colOffset;
                    
                    if (this.isInBounds(newRow, newCol)) {
                        const targetPiece = this.board[newRow][newCol];
                        if (!targetPiece || !targetPiece.endsWith(color)) {
                            moves.push([newRow, newCol]);
                        }
                    }
                }
                
                // Castling moves
                if (this.canCastle(row, col, color)) {
                    // Check kingside castling
                    if (this.castlingRights[color].kingSide && 
                        !this.board[row][col+1] && 
                        !this.board[row][col+2]) {
                        
                        // Check if squares are attacked
                        if (!this.isSquareAttacked(row, col, color) && 
                            !this.isSquareAttacked(row, col+1, color) && 
                            !this.isSquareAttacked(row, col+2, color)) {
                            moves.push([row, col+2]);
                        }
                    }
                    
                    // Check queenside castling
                    if (this.castlingRights[color].queenSide && 
                        !this.board[row][col-1] && 
                        !this.board[row][col-2] && 
                        !this.board[row][col-3]) {
                        
                        // Check if squares are attacked
                        if (!this.isSquareAttacked(row, col, color) && 
                            !this.isSquareAttacked(row, col-1, color) && 
                            !this.isSquareAttacked(row, col-2, color)) {
                            moves.push([row, col-2]);
                        }
                    }
                }
            }
            
            canCastle(row, col, color) {
                // King must be in original position and not in check
                if (color === 'white' && row === 7 && col === 4 && !this.isInCheck.white) {
                    return true;
                }
                if (color === 'black' && row === 0 && col === 4 && !this.isInCheck.black) {
                    return true;
                }
                return false;
            }
            
            isSquareAttacked(row, col, defendingColor) {
                const attackingColor = defendingColor === 'white' ? 'black' : 'white';
                
                // Check attacks from pawns
                const pawnDirections = defendingColor === 'white' ? [[1, -1], [1, 1]] : [[-1, -1], [-1, 1]];
                for (const [rowDir, colDir] of pawnDirections) {
                    const checkRow = row + rowDir;
                    const checkCol = col + colDir;
                    
                    if (this.isInBounds(checkRow, checkCol)) {
                        const piece = this.board[checkRow][checkCol];
                        if (piece === `pawn-${attackingColor}`) {
                            return true;
                        }
                    }
                }
                
                // Check attacks from knights
                const knightOffsets = [
                    [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                    [1, -2], [1, 2], [2, -1], [2, 1]
                ];
                
                for (const [rowOffset, colOffset] of knightOffsets) {
                    const checkRow = row + rowOffset;
                    const checkCol = col + colOffset;
                    
                    if (this.isInBounds(checkRow, checkCol)) {
                        const piece = this.board[checkRow][checkCol];
                        if (piece === `knight-${attackingColor}`) {
                            return true;
                        }
                    }
                }
                
                // Check attacks from king
                const kingOffsets = [
                    [-1, -1], [-1, 0], [-1, 1],
                    [0, -1], [0, 1],
                    [1, -1], [1, 0], [1, 1]
                ];
                
                for (const [rowOffset, colOffset] of kingOffsets) {
                    const checkRow = row + rowOffset;
                    const checkCol = col + colOffset;
                    
                    if (this.isInBounds(checkRow, checkCol)) {
                        const piece = this.board[checkRow][checkCol];
                        if (piece === `king-${attackingColor}`) {
                            return true;
                        }
                    }
                }
                
                // Check attacks from rooks and queens (horizontal and vertical)
                const straightDirections = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                for (const [rowDir, colDir] of straightDirections) {
                    let checkRow = row + rowDir;
                    let checkCol = col + colDir;
                    
                    while (this.isInBounds(checkRow, checkCol)) {
                        const piece = this.board[checkRow][checkCol];
                        if (piece) {
                            if (piece === `rook-${attackingColor}` || piece === `queen-${attackingColor}`) {
                                return true;
                            }
                            break; // Blocked by another piece
                        }
                        checkRow += rowDir;
                        checkCol += colDir;
                    }
                }
                
                // Check attacks from bishops and queens (diagonal)
                const diagonalDirections = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
                for (const [rowDir, colDir] of diagonalDirections) {
                    let checkRow = row + rowDir;
                    let checkCol = col + colDir;
                    
                    while (this.isInBounds(checkRow, checkCol)) {
                        const piece = this.board[checkRow][checkCol];
                        if (piece) {
                            if (piece === `bishop-${attackingColor}` || piece === `queen-${attackingColor}`) {
                                return true;
                            }
                            break; // Blocked by another piece
                        }
                        checkRow += rowDir;
                        checkCol += colDir;
                    }
                }
                
                return false;
            }
            
            isKingInCheck(color) {
                const [kingRow, kingCol] = this.kingPositions[color];
                return this.isSquareAttacked(kingRow, kingCol, color);
            }
            
            isInBounds(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }
            
            truncateMoveHistory() {
                // Remove all moves after the current index
                this.moveHistory = this.moveHistory.slice(0, this.currentMoveIndex);
                this.boardStates = this.boardStates.slice(0, this.currentMoveIndex + 1);
                
                // Clear the notation display from this point forward
                const notationBody = document.getElementById('notation-body');
                const rows = notationBody.getElementsByTagName('tr');
                
                let rowIndex = Math.ceil(this.currentMoveIndex / 2);
                // If we're truncating after white's move, keep the row but clear black's move
                if (this.currentMoveIndex % 2 === 1 && rowIndex < rows.length) {
                    const cells = rows[rowIndex - 1].getElementsByTagName('td');
                    if (cells.length >= 3) {
                        cells[2].textContent = '';
                    }
                    // Remove all subsequent rows
                    while (rows.length > rowIndex) {
                        notationBody.removeChild(rows[rowIndex]);
                    }
                } else {
                    // Remove all rows from this point
                    while (rows.length > rowIndex) {
                        notationBody.removeChild(rows[rowIndex]);
                    }
                }
            }
            
            makeMove(fromRow, fromCol, toRow, toCol, promotionPiece = null) {
                const piece = this.board[fromRow][fromCol];
                const capturedPiece = this.board[toRow][toCol];
                const [pieceType, color] = piece.split('-');
                const opponentColor = color === 'white' ? 'black' : 'white';
                
                let specialMove = '';
                let enPassantCapture = null;
                let promotedPiece = null;
                let castling = null;
                
                // Reset en passant target
                const oldEnPassantTarget = this.enPassantTarget;
                this.enPassantTarget = null;
                
                // Handle pawn special moves
                if (pieceType === 'pawn') {
                    // Check for en passant capture
                    if (fromCol !== toCol && !capturedPiece) {
                        const enPassantRow = color === 'white' ? toRow + 1 : toRow - 1;
                        enPassantCapture = [enPassantRow, toCol];
                        
                        // Capture the pawn
                        const capturedPawn = this.board[enPassantRow][toCol];
                        this.board[enPassantRow][toCol] = null;
                        this.capturedPieces[color].push(capturedPawn);
                        
                        specialMove = 'en passant';
                    }
                    
                    // Check for pawn promotion
                    if ((color === 'white' && toRow === 0) || (color === 'black' && toRow === 7)) {
                        promotedPiece = promotionPiece || 'queen'; // Default to queen if not specified
                        this.board[fromRow][fromCol] = null;
                        this.board[toRow][toCol] = `${promotedPiece}-${color}`;
                        
                        specialMove = 'promotion';
                    }
                    
                    // Set en passant target for double move
                    if (Math.abs(fromRow - toRow) === 2) {
                        const enPassantRow = color === 'white' ? toRow + 1 : toRow - 1;
                        this.enPassantTarget = [enPassantRow, toCol];
                    }
                }
                
                // Handle castling
                if (pieceType === 'king' && Math.abs(fromCol - toCol) > 1) {
                    const isKingsideCastling = toCol > fromCol;
                    const rookFromCol = isKingsideCastling ? 7 : 0;
                    const rookToCol = isKingsideCastling ? 5 : 3;
                    
                    // Move the rook
                    const rook = this.board[fromRow][rookFromCol];
                    this.board[fromRow][rookToCol] = rook;
                    this.board[fromRow][rookFromCol] = null;
                    
                    castling = isKingsideCastling ? 'kingside' : 'queenside';
                    specialMove = `castling ${castling}`;
                }
                
                // Update castling rights
                if (pieceType === 'king') {
                    this.castlingRights[color].kingSide = false;
                    this.castlingRights[color].queenSide = false;
                    
                    // Update king position
                    this.kingPositions[color] = [toRow, toCol];
                }
                
                if (pieceType === 'rook') {
                    if (fromRow === 7 && fromCol === 0 && color === 'white') {
                        this.castlingRights.white.queenSide = false;
                    } else if (fromRow === 7 && fromCol === 7 && color === 'white') {
                        this.castlingRights.white.kingSide = false;
                    } else if (fromRow === 0 && fromCol === 0 && color === 'black') {
                        this.castlingRights.black.queenSide = false;
                    } else if (fromRow === 0 && fromCol === 7 && color === 'black') {
                        this.castlingRights.black.kingSide = false;
                    }
                }
                
                // If a rook is captured, update castling rights
                if (capturedPiece === 'rook-white') {
                    if (toRow === 7 && toCol === 0) this.castlingRights.white.queenSide = false;
                    if (toRow === 7 && toCol === 7) this.castlingRights.white.kingSide = false;
                } else if (capturedPiece === 'rook-black') {
                    if (toRow === 0 && toCol === 0) this.castlingRights.black.queenSide = false;
                    if (toRow === 0 && toCol === 7) this.castlingRights.black.kingSide = false;
                }
                
                // Save move for history
                this.moveHistory.push({
                    from: [fromRow, fromCol],
                    to: [toRow, toCol],
                    piece,
                    capturedPiece,
                    player: color,
                    enPassantCapture,
                    promotedPiece,
                    castling,
                    enPassantTarget: oldEnPassantTarget,
                    castlingRights: JSON.parse(JSON.stringify(this.castlingRights)),
                    specialMove
                });
                
                // Capture piece if any
                if (capturedPiece && !enPassantCapture) {
                    this.capturedPieces[color].push(capturedPiece);
                }
                
                // Move piece (if not already handled by promotion)
                if (!promotedPiece) {
                    this.board[toRow][toCol] = piece;
                    this.board[fromRow][fromCol] = null;
                }
                
                // Switch player
                this.currentPlayer = opponentColor;
                
                // Check if opponent is in check or checkmate
                this.isInCheck.white = this.isKingInCheck('white');
                this.isInCheck.black = this.isKingInCheck('black');
                
                // Check for checkmate or stalemate
                this.checkGameEndConditions();
                
                // Store the new board state
                this.boardStates.push(this.deepCopyBoard(this.board));
                
                // Set current move index to latest move
                this.currentMoveIndex = this.moveHistory.length;
                
                // Update UI
                this.setupBoard();
                this.addMoveToHistory(fromRow, fromCol, toRow, toCol, piece, capturedPiece, specialMove);
                
                // Update navigation buttons
                this.updateNavigationButtons();
            }
            
            checkGameEndConditions() {
                const currentColor = this.currentPlayer;
                const hasLegalMoves = this.playerHasLegalMoves(currentColor);
                
                if (!hasLegalMoves) {
                    if (this.isInCheck[currentColor]) {
                        // Checkmate
                        this.gameOver = true;
                        this.gameStatus = `Checkmate! ${currentColor === 'white' ? 'Black' : 'White'} wins`;
                    } else {
                        // Stalemate
                        this.gameOver = true;
                        this.gameStatus = 'Stalemate! Game is a draw';
                    }
                } else if (this.isInCheck[currentColor]) {
                    // Just in check
                    this.gameStatus = `${currentColor === 'white' ? 'White' : 'Black'} is in check!`;
                } else {
                    this.gameStatus = '';
                }
            }
            
            playerHasLegalMoves(color) {
                // Check all pieces of this color
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.endsWith(color)) {
                            const legalMoves = this.calculateLegalMoves(row, col);
                            if (legalMoves.length > 0) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            promptPromotion(fromRow, fromCol, toRow, toCol) {
                this.promotionPending = true;
                this.promotionMove = { fromRow, fromCol, toRow, toCol };
                
                const modal = document.getElementById('promotion-modal');
                const piecesContainer = document.getElementById('promotion-pieces');
                piecesContainer.innerHTML = '';
                
                const color = this.board[fromRow][fromCol].split('-')[1];
                const pieceTypes = ['queen', 'rook', 'bishop', 'knight'];
                
                // Mapping function to convert our piece names to standard notation
                const getPieceImage = (piece) => {
                    if (!piece) return null;
                    
                    const pieceMap = {
                        'queen-white': 'wQ', 'rook-white': 'wR', 'bishop-white': 'wB', 'knight-white': 'wN',
                        'queen-black': 'bQ', 'rook-black': 'bR', 'bishop-black': 'bB', 'knight-black': 'bN'
                    };
                    
                    return pieceMap[piece];
                };
                
                pieceTypes.forEach(type => {
                    const pieceElement = document.createElement('div');
                    pieceElement.classList.add('promotion-piece');
                    pieceElement.dataset.piece = type;
                    
                    const pieceFileName = getPieceImage(`${type}-${color}`);
                    pieceElement.style.backgroundImage = `url('img/${pieceFileName}.png')`;
                    piecesContainer.appendChild(pieceElement);
                });
                
                modal.style.display = 'flex';
            }
            
            completePromotion(pieceType) {
                const { fromRow, fromCol, toRow, toCol } = this.promotionMove;
                
                // Close the modal
                document.getElementById('promotion-modal').style.display = 'none';
                
                // Check if we're in the middle of the move history
                if (this.currentMoveIndex < this.moveHistory.length) {
                    // Truncate move history and boardStates at current position
                    this.truncateMoveHistory();
                }
                
                // Complete the move with the promoted piece
                this.makeMove(fromRow, fromCol, toRow, toCol, pieceType);
                
                this.promotionPending = false;
                this.promotionMove = null;
            }
            
            addMoveToHistory(fromRow, fromCol, toRow, toCol, piece, capturedPiece, specialMove = '') {
                const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
                const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];
                
                const fromSquare = files[fromCol] + ranks[fromRow];
                const toSquare = files[toCol] + ranks[toRow];
                
                // Get piece type (P, N, B, R, Q, K)
                let pieceType = piece.split('-')[0][0].toUpperCase();
                // Knights use 'N' instead of 'K' in algebraic notation
                if (pieceType === 'K' && piece.includes('knight')) pieceType = 'N';
                // Pawns have no prefix in algebraic notation
                if (pieceType === 'P') pieceType = '';
                
                // Build the move in algebraic notation
                let notation = '';
                
                // Handle castling
                if (specialMove.includes('castling')) {
                    if (specialMove.includes('kingside')) {
                        notation = 'O-O';
                    } else {
                        notation = 'O-O-O';
                    }
                } else {
                    if (capturedPiece || specialMove.includes('en passant')) {
                        // Captures
                        if (pieceType === '') {
                            // Pawn captures include the file
                            notation = files[fromCol] + 'x' + files[toCol] + ranks[toRow];
                        } else {
                            notation = pieceType + 'x' + files[toCol] + ranks[toRow];
                        }
                    } else {
                        // Non-captures
                        notation = pieceType + files[toCol] + ranks[toRow];
                    }
                    
                    // Add promotion
                    if (specialMove.includes('promotion')) {
                        const promotedTo = piece.split('-')[0][0].toUpperCase();
                        notation += '=' + (promotedTo === 'K' && piece.includes('knight') ? 'N' : promotedTo);
                    }
                }
                
                // Add check or checkmate
                if (this.gameStatus.includes('Checkmate')) {
                    notation += '#';
                } else if (this.isInCheck.white || this.isInCheck.black) {
                    notation += '+';
                }
                
                // Add to the table in the proper format
                const notationBody = document.getElementById('notation-body');
                
                // Get the player color for this move
                const color = piece.split('-')[1];
                
                if (color === 'white') {
                    // Create a new row for white's move
                    const tr = document.createElement('tr');
                    tr.dataset.moveIndex = this.moveHistory.length;
                    
                    const tdNum = document.createElement('td');
                    tdNum.textContent = Math.floor(this.moveHistory.length / 2) + 1 + '.';
                    
                    const tdWhite = document.createElement('td');
                    tdWhite.textContent = notation;
                    
                    const tdBlack = document.createElement('td');
                    // Black's move will be filled in later
                    
                    tr.appendChild(tdNum);
                    tr.appendChild(tdWhite);
                    tr.appendChild(tdBlack);
                    notationBody.appendChild(tr);
                } else {
                    // Add black's move to the last row
                    const rows = notationBody.getElementsByTagName('tr');
                    if (rows.length > 0) {
                        const lastRow = rows[rows.length - 1];
                        const cells = lastRow.getElementsByTagName('td');
                        if (cells.length >= 3) {
                            cells[2].textContent = notation;
                        }
                    }
                }
                
                // Scroll to the bottom of the move history
                const moveHistory = document.getElementById('move-history');
                moveHistory.scrollTop = moveHistory.scrollHeight;
                
                // Highlight the current move
                this.highlightNotationRow(this.moveHistory.length);
            }
            
            highlightNotationRow(moveIndex) {
                // Remove highlight from all cells
                document.querySelectorAll('.notation-table td').forEach(cell => {
                    cell.classList.remove('active');
                });
                
                if (moveIndex <= 0) return;
                
                // Calculate which row and column to highlight
                const rowIndex = Math.ceil(moveIndex / 2) - 1;
                const isWhiteMove = moveIndex % 2 === 1; // White moves are odd indices
                const columnIndex = isWhiteMove ? 1 : 2; // 1 for white, 2 for black
                
                // Get the rows in the notation table
                const rows = document.getElementById('notation-body').getElementsByTagName('tr');
                
                // Highlight the specific cell if it exists
                if (rowIndex >= 0 && rowIndex < rows.length) {
                    const cells = rows[rowIndex].getElementsByTagName('td');
                    if (columnIndex < cells.length) {
                        cells[columnIndex].classList.add('active');
                    }
                }
            }
            
            goToMove(moveIndex) {
                if (moveIndex < 0 || moveIndex > this.moveHistory.length) return;
                
                // Reset the game state first
                this.board = this.createInitialBoard();
                this.kingPositions = { white: [7, 4], black: [0, 4] };
                this.isInCheck = { white: false, black: false };
                this.castlingRights = {
                    white: { kingSide: true, queenSide: true },
                    black: { kingSide: true, queenSide: true }
                };
                this.enPassantTarget = null;
                this.capturedPieces = { white: [], black: [] };
                this.gameOver = false;
                this.gameStatus = '';
                
                // Replay all moves up to the requested index
                for (let i = 0; i < moveIndex; i++) {
                    const move = this.moveHistory[i];
                    
                    // Handle regular move
                    const piece = this.board[move.from[0]][move.from[1]];
                    
                    // Handle captures
                    if (move.capturedPiece) {
                        this.capturedPieces[move.player].push(move.capturedPiece);
                    }
                    
                    // Handle en passant capture
                    if (move.enPassantCapture) {
                        const capturedPawn = this.board[move.enPassantCapture[0]][move.enPassantCapture[1]];
                        this.board[move.enPassantCapture[0]][move.enPassantCapture[1]] = null;
                        this.capturedPieces[move.player].push(capturedPawn);
                    }
                    
                    // Handle castling
                    if (move.castling) {
                        const row = move.from[0];
                        const rookFromCol = move.castling === 'kingside' ? 7 : 0;
                        const rookToCol = move.castling === 'kingside' ? 5 : 3;
                        
                        // Move the rook
                        const rook = this.board[row][rookFromCol];
                        this.board[row][rookToCol] = rook;
                        this.board[row][rookFromCol] = null;
                    }
                    
                    // Handle pawn promotion
                    if (move.promotedPiece) {
                        this.board[move.to[0]][move.to[1]] = `${move.promotedPiece}-${move.player}`;
                        this.board[move.from[0]][move.from[1]] = null;
                    } else {
                        // Regular move
                        this.board[move.to[0]][move.to[1]] = piece;
                        this.board[move.from[0]][move.from[1]] = null;
                    }
                    
                    // Update king position if king moved
                    if (piece && piece.startsWith('king')) {
                        this.kingPositions[move.player] = [move.to[0], move.to[1]];
                    }
                    
                    // Update castling rights
                    if (move.castlingRights) {
                        this.castlingRights = JSON.parse(JSON.stringify(move.castlingRights));
                    }
                    
                    // Set en passant target
                    this.enPassantTarget = move.enPassantTarget;
                }
                
                this.currentMoveIndex = moveIndex;
                
                // Determine the current player
                this.currentPlayer = moveIndex % 2 === 0 ? 'white' : 'black';
                
                // Update check status
                this.isInCheck.white = this.isKingInCheck('white');
                this.isInCheck.black = this.isKingInCheck('black');
                
                // Check for game end conditions if at the latest move
                if (moveIndex === this.moveHistory.length) {
                    this.checkGameEndConditions();
                } else {
                    this.gameOver = false;
                    this.gameStatus = '';
                }
                
                // Update UI
                this.setupBoard();
                this.highlightNotationRow(moveIndex);
                this.updateNavigationButtons();
            }
            
            updateNavigationButtons() {
                // Disable/enable navigation buttons based on current position
                document.getElementById('first-move').disabled = this.currentMoveIndex === 0;
                document.getElementById('prev-move').disabled = this.currentMoveIndex === 0;
                document.getElementById('next-move').disabled = this.currentMoveIndex === this.moveHistory.length;
                document.getElementById('last-move').disabled = this.currentMoveIndex === this.moveHistory.length;
            }
            
            flipBoard() {
                this.boardOrientation = this.boardOrientation === 'white' ? 'black' : 'white';
                this.setupBoard();
            }
            
            resetGame() {
                this.board = this.createInitialBoard();
                this.currentPlayer = 'white';
                this.selectedPiece = null;
                this.possibleMoves = [];
                this.moveHistory = [];
                this.capturedPieces = { white: [], black: [] };
                this.currentMoveIndex = 0;
                this.boardStates = [this.deepCopyBoard(this.board)];
                this.kingPositions = { white: [7, 4], black: [0, 4] };
                this.isInCheck = { white: false, black: false };
                this.gameOver = false;
                this.gameStatus = '';
                this.castlingRights = {
                    white: { kingSide: true, queenSide: true },
                    black: { kingSide: true, queenSide: true }
                };
                this.enPassantTarget = null;
                
                // Reset move history display
                document.getElementById('notation-body').innerHTML = '';
                
                this.setupBoard();
                this.updateNavigationButtons();
            }
            
            updateTurnIndicator() {
                document.getElementById('turn-indicator').textContent = `Current Turn: ${this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1)}`;
            }
            
            updateGameStatus() {
                document.getElementById('game-status').textContent = this.gameStatus;
            }
            
            updateCapturedPieces() {
                const whiteContainer = document.getElementById('captured-white');
                const blackContainer = document.getElementById('captured-black');
                
                whiteContainer.innerHTML = '';
                blackContainer.innerHTML = '';
                
                // Mapping function to convert our piece names to standard notation
                const getPieceImage = (piece) => {
                    if (!piece) return null;
                    
                    const pieceMap = {
                        'pawn-white': 'wP', 'rook-white': 'wR', 'knight-white': 'wN', 
                        'bishop-white': 'wB', 'queen-white': 'wQ', 'king-white': 'wK',
                        'pawn-black': 'bP', 'rook-black': 'bR', 'knight-black': 'bN', 
                        'bishop-black': 'bB', 'queen-black': 'bQ', 'king-black': 'bK'
                    };
                    
                    return pieceMap[piece];
                };
                
                this.capturedPieces.white.forEach(piece => {
                    const pieceElement = document.createElement('div');
                    pieceElement.classList.add('captured-piece');
                    const pieceFileName = getPieceImage(piece);
                    pieceElement.style.backgroundImage = `url('img/${pieceFileName}.png')`;
                    whiteContainer.appendChild(pieceElement);
                });
                
                this.capturedPieces.black.forEach(piece => {
                    const pieceElement = document.createElement('div');
                    pieceElement.classList.add('captured-piece');
                    const pieceFileName = getPieceImage(piece);
                    pieceElement.style.backgroundImage = `url('img/${pieceFileName}.png')`;
                    blackContainer.appendChild(pieceElement);
                });
            }
            
            // PGN Export - Convert the game's move history to PGN format
            generatePGN() {
                // Create PGN header with tag pairs
                const date = new Date();
                const dateStr = date.toISOString().split('T')[0].replace(/-/g, '.');
                
                let pgn = '';
                pgn += '[Event "Casual Game"]\n';
                pgn += '[Site "Web Chess"]\n';
                pgn += '[Date "' + dateStr + '"]\n';
                pgn += '[Round "?"]\n';
                pgn += '[White "Player 1"]\n';
                pgn += '[Black "Player 2"]\n';
                pgn += '[Result "' + this.getPGNResult() + '"]\n';
                pgn += '\n';
                
                // Generate movetext
                let moveNumber = 1;
                let moveLine = '';
                
                for (let i = 0; i < this.moveHistory.length; i++) {
                    // Get the move notation from the UI
                    const moveIndex = i + 1;
                    const rowIndex = Math.ceil(moveIndex / 2) - 1;
                    const isWhiteMove = moveIndex % 2 === 1;
                    const columnIndex = isWhiteMove ? 1 : 2;
                    
                    const rows = document.getElementById('notation-body').getElementsByTagName('tr');
                    if (rowIndex >= 0 && rowIndex < rows.length) {
                        const cells = rows[rowIndex].getElementsByTagName('td');
                        
                        if (isWhiteMove) {
                            // Start a new move number for white's move
                            moveLine += moveNumber + '. ';
                            moveNumber++;
                        }
                        
                        if (columnIndex < cells.length && cells[columnIndex].textContent) {
                            moveLine += cells[columnIndex].textContent + ' ';
                        }
                    }
                    
                    // Add a newline every 5 moves (10 half-moves) for readability
                    if (moveIndex % 10 === 0) {
                        moveLine += '\n';
                    }
                }
                
                // Add result
                moveLine += this.getPGNResult();
                
                pgn += moveLine;
                return pgn;
            }
            
            getPGNResult() {
                if (!this.gameOver) return '*'; // Game in progress
                
                if (this.gameStatus.includes('Checkmate')) {
                    if (this.currentPlayer === 'white') {
                        return '0-1'; // Black wins
                    } else {
                        return '1-0'; // White wins
                    }
                } else if (this.gameStatus.includes('Stalemate')) {
                    return '1/2-1/2'; // Draw
                }
                
                return '*'; // Unknown/game in progress
            }
            
            savePGN() {
                const pgn = this.generatePGN();
                const blob = new Blob([pgn], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'chess_game.pgn';
                document.body.appendChild(a);
                a.click();
                
                // Clean up
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            }
            
            loadPGN(pgnText) {
                try {
                    // Reset the game first
                    this.resetGame();
                    
                    // Parse PGN
                    const lines = pgnText.split('\n');
                    let tagSection = true;
                    let movesText = '';
                    
                    // Extract moves text
                    for (const line of lines) {
                        if (line.trim() === '') {
                            if (tagSection) tagSection = false;
                            continue;
                        }
                        
                        if (!tagSection) {
                            movesText += line + ' ';
                        }
                    }
                    
                    // Parse moves
                    movesText = movesText.trim();
                    // Remove result from the end if present
                    movesText = movesText.replace(/\s+1-0$|\s+0-1$|\s+1\/2-1\/2$|\s+\*$/, '');
                    
                    // Extract individual moves
                    const moveRegex = /\d+\.\s+([^\s]+)(?:\s+([^\s]+))?/g;
                    let match;
                    
                    while ((match = moveRegex.exec(movesText)) !== null) {
                        const whiteMove = match[1];
                        const blackMove = match[2];
                        
                        // Process white's move
                        this.processAlgebraicNotation(whiteMove);
                        
                        // Process black's move if present
                        if (blackMove) {
                            this.processAlgebraicNotation(blackMove);
                        }
                    }
                    
                    // Update the board with final position
                    this.goToMove(this.moveHistory.length);
                    
                } catch (error) {
                    console.error('Error loading PGN:', error);
                    alert('Error loading PGN file. Please check the file format.');
                }
            }
            
            processAlgebraicNotation(moveNotation) {
                if (!moveNotation) return;
                
                // Handle special notations first
                if (moveNotation === 'O-O' || moveNotation === 'O-O-O') {
                    return this.processCastlingMove(moveNotation);
                }
                
                // Strip check/checkmate symbols
                moveNotation = moveNotation.replace(/[+#]$/, '');
                
                // Handle pawn promotion
                let promotionPiece = null;
                if (moveNotation.includes('=')) {
                    const parts = moveNotation.split('=');
                    moveNotation = parts[0];
                    const promoteTo = parts[1];
                    
                    // Convert promotion piece notation to our format
                    const pieceMap = { 'Q': 'queen', 'R': 'rook', 'B': 'bishop', 'N': 'knight' };
                    promotionPiece = pieceMap[promoteTo] || 'queen';
                }
                
                // Parse piece type, capture, and destination
                let pieceType = 'pawn'; // Default is pawn
                let capture = false;
                let sourceFile = null;
                let sourceRank = null;
                let destFile = null;
                let destRank = null;
                
                if (moveNotation[0] === moveNotation[0].toUpperCase() && 
                    'KQRBN'.includes(moveNotation[0])) {
                    // This is a piece move (not a pawn)
                    const pieceMap = { 'K': 'king', 'Q': 'queen', 'R': 'rook', 'B': 'bishop', 'N': 'knight' };
                    pieceType = pieceMap[moveNotation[0]];
                    moveNotation = moveNotation.substring(1);
                }
                
                // Check for captures
                if (moveNotation.includes('x')) {
                    capture = true;
                    // For pawn captures, the first character is the source file
                    if (pieceType === 'pawn' && moveNotation[0] >= 'a' && moveNotation[0] <= 'h') {
                        sourceFile = moveNotation[0];
                    }
                    moveNotation = moveNotation.replace('x', '');
                }
                
                // Handle disambiguation (when multiple pieces can move to the same square)
                if (pieceType !== 'pawn' && moveNotation.length > 2) {
                    // If we have something like Nbd7, the 'b' is the source file
                    if (moveNotation.length === 3 && moveNotation[0] >= 'a' && moveNotation[0] <= 'h') {
                        sourceFile = moveNotation[0];
                        moveNotation = moveNotation.substring(1);
                    }
                    // If we have something like N1d7, the '1' is the source rank
                    else if (moveNotation.length === 3 && moveNotation[0] >= '1' && moveNotation[0] <= '8') {
                        sourceRank = moveNotation[0];
                        moveNotation = moveNotation.substring(1);
                    }
                    // If we have something like Nb1d7, 'b1' is the source square
                    else if (moveNotation.length === 4) {
                        sourceFile = moveNotation[0];
                        sourceRank = moveNotation[1];
                        moveNotation = moveNotation.substring(2);
                    }
                }
                
                // Get destination square
                if (moveNotation.length >= 2) {
                    destFile = moveNotation[0];
                    destRank = moveNotation[1];
                } else {
                    console.error('Invalid move notation:', moveNotation);
                    return;
                }
                
                // Convert algebraic coordinates to array indices
                const fileToCol = { 'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7 };
                const rankToRow = { '8': 0, '7': 1, '6': 2, '5': 3, '4': 4, '3': 5, '2': 6, '1': 7 };
                
                let destCol = fileToCol[destFile];
                let destRow = rankToRow[destRank];
                
                // Find the piece that can make this move
                const color = this.currentPlayer;
                let foundPiece = false;
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        
                        // Skip empty squares or opponent's pieces
                        if (!piece || !piece.endsWith(color)) continue;
                        
                        // Check if this piece matches the type we're looking for
                        const [currentPieceType] = piece.split('-');
                        if (currentPieceType !== pieceType) continue;
                        
                        // Check if this piece matches source file/rank constraints
                        if (sourceFile && fileToCol[sourceFile] !== col) continue;
                        if (sourceRank && rankToRow[sourceRank] !== row) continue;
                        
                        // Check if this piece can legally move to the destination
                        const legalMoves = this.calculateLegalMoves(row, col);
                        const canMoveToTarget = legalMoves.some(([r, c]) => r === destRow && c === destCol);
                        
                        if (canMoveToTarget) {
                            // We found the piece that can make this move
                            if (promotionPiece) {
                                this.makeMove(row, col, destRow, destCol, promotionPiece);
                            } else {
                                this.makeMove(row, col, destRow, destCol);
                            }
                            foundPiece = true;
                            break;
                        }
                    }
                    if (foundPiece) break;
                }
                
                if (!foundPiece) {
                    console.error('Could not find piece for move:', moveNotation);
                }
            }
            
            processCastlingMove(moveNotation) {
                const isKingside = moveNotation === 'O-O';
                const color = this.currentPlayer;
                const row = color === 'white' ? 7 : 0;
                const kingCol = 4;
                
                // Get king
                const king = this.board[row][kingCol];
                if (!king || !king.startsWith('king')) {
                    console.error('King not found for castling:', moveNotation);
                    return;
                }
                
                // Destination column for king
                const destCol = isKingside ? 6 : 2;
                
                // Make the castling move
                this.makeMove(row, kingCol, row, destCol);
                return true;
            }
        }
        
        // Initialize the game when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            const game = new ChessGame();
        });
    </script>
</body>
</html>